Scan variable !
Scanner scan = new Scanner(System.in);


scan.next(); // returns the next token of input
scan.hasNext(); // returns true if there is another token of input (false otherwise)
scan.nextLine() // returns the next LINE of input
scan.hasNextLine(); // returns true if there is another line of iput

scan.close();


-------------------------------------------------------------------------------------
a b c
d e
f
g

The breakdown below shows how a certain sequence of calls to a Scanner object, , will read the above input:
A call to scan.next(); returns the next token, a.
A call to scan.next(); returns the next token, b.
A call to scan.nextLine(); returns the next token, c. It's important to note that the scanner returns a space and a letter, because it's reading from the end of the last token until the beginning of the next line.
A call to scan.nextLine(); returns the contents of the next line, d e.
A call to scan.next(); returns the next token, f.
A call to scan.nextLine(); returns everything after f until the beginning of the next line; because there are no characters there, it returns an empty String.
A call to scan.nextLine(); returns g.
-------------------------------------------------------------------------------------

Day 3

v = c ? a : b;

switch (condition) {
    case val0: 	behavior0;
                break;
    case val1:	behavior1;
                break;
    case val2:	behavior2;
                break;
    default: 	behavior;
                break;
}

-------------------------------------------------------------------------------------

Day 4 Class Vs Instance

Each class has two types of variables: class variables and instance variables; class variables point to the same (static) variable across all instances of a class, and instance variables have distinct values that vary from instance to instance.

Creates an instance of a class (i.e.: calling the Dog constructor creates an instance of Dog). A class can have one or more constructors that build different versions of the same type of object. A constructor with no parameters is called a default constructor; it creates an object with default initial values specified by the programmer. A constructor that takes one or more parameters (i.e.: values in parentheses) is called a parameterized constructor. Many languages allow you to have multiple constructors, provided that each constructor takes different types of parameters; these are called overloaded constructors.

class Dog{ // class name
    static String unnamed = "I need a name!"; // class variable
    int weight; // instance variable
    String name; // instance variable
    String coatColor; // instance variable
    
    Dog(){ // default constructor
        this.weight = 0;
        this.name = unnamed;
        this.coatColor = "none";
    }
    Dog(int weight, String color){ // parameterized constructor
        // initialize instance variables
        this.weight = weight; // assign parameter's value to instance variable
        this.name = unnamed; 
        this.coatColor = color; 
    }
    Dog(String dogName, String color){ // overloaded parameterized constructor
        // initialize instance variables
        this.weight = 0;
        this.name = dogName; 
        this.coatColor = color; 
    }
}


Most classes will have methods called getters and setters that get (return) or set the values of its instance variables. Standard getter/setter syntax:
class MyClass{
    dataType instanceVariable;
    ...
    void setInstanceVariable(int value){
        this.instanceVariable = value;
    }
    dataType getInstanceVariable(){
        return instanceVariable;
    }
}

Difference b/w parameter and argument

Parameter
A parenthetical variable in a function or constructor declaration (e.g.: in int methodOne(int x), the parameter is int x). 

Argument
The actual value of a parameter (e.g.: in methodOne(5), the argument passed as variable x is 5). 


//Day 5 Loops

Unlabeled Break
You may recall break; from our previous discussion of Switch Statements. It will break you out of a loop even if the loop's termination condition still holds true. 

do{
    // this will execute once
    // it will execute again each time while(condition) is true
} while(condition);


int min = 0;
int max = 4;
while(min < max){
    System.out.println(min++);
}





//Day 6

char myChar = 'c'; // create char c
System.out.println("The ASCII value of " + myChar + " is: " + (int) myChar);
Output:
The ASCII value of c is: 99

Observe the (int) before the variable name in the code above. This is called explicit casting, which is a method of representing one thing as another. Putting a data type inside parentheses right before a variable is essentially saying: "The next thing after this should be represented as this data type". Casting only works for certain types of relationships, such as between primitives or objects that inherit from another class. 

To break a String down into its component characters, you can use the String.toCharArray method. For example, this code:
String myString = "This is String example.";
char[] myCharArray = myString.toCharArray();
for(int i = 0; i < myString.length(); i++){
    // Print each sequential character on the same line
    System.out.print(myCharArray[i]); 
}
// Print a newline
System.out.println(); 
produces this output:
This is String example.
Notice that we were able to simulate printing myString by instead printing each individual character in the character array, myCharArray, created from myString.


// Day 7 Arrays

// the number of elements we want to hold
final int _arraySize = 4; 

// our array declaration
String[] stringArray = new String[_arraySize]; 

for(int i = 0; i < _arraySize; i++) {
    // assign value to index i
    stringArray[i] = "This is stored in index " + i; 
    
    // print value saved in index i
    System.out.println(stringArray[i]); 
}

Note: The final keyword used in the code above is a means of protecting the variable's value by locking it to its initialized value. Any attempt to reassign (overwrite) the value of a final variable will generate an error.


 Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int i=0; i < n; i++){
            arr[i] = in.nextInt();
        }
        in.close();


        use in.close 


        